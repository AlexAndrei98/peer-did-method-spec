<!DOCTYPE html>
<html>
<head>
    <meta charset='utf-8'>
    <title>Peer DID Method Specification</title>
    <style>
        #instructions {
          border: dashed 1px black;
          padding: 1em;
          background-color:#d0d0d0;
        }
        .replace-me {
          font-style:italic;
          color:magenta
        }

    </style>
    <script src='https://www.w3.org/Tools/respec/respec-w3c-common' class='remove'></script>
    <script class='remove'>
      var respecConfig = {
        specStatus: "ED",
        editors: [
          {
            name: "Daniel Hardman",
            url: "https://github.com/dhh1128",
            company: "Hyperledger Aries Project / Sovrin Foundation / Evernym",
            companyURL: "https://github.com/hyperledger/aries",
            mailto: "daniel.hardman@gmail.com"
          }
        ],
        authors: [
          {
            name: "Oskar Deventer",
            url: "https://github.com/Oskar-van-Deventer",
            company: "TNO",
            companyURL: "https://tno.nl"
          },
          {
            name: "Christian Lundkvist",
            url: "https://github.com/christianlundkvist",
            company: "ConsenSys",
            companyURL: "https://consensys.net"
          },
          {
            name: "Marton Csernai",
            url: "https://github.com/csmarc",
            company: "KILT",
            companyURL: "https://kilt.io"
          },
          {
            name: "Brent Zundel",
            url: "https://github.com/brentzundel",
            company: "Evernym",
            companyURL: "https://evernym.com"
          },
          {
            name: "Sam Curren",
            url: "https://github.com/TelegramSam",
            company: "Sovrin Foundation / Decentralized Identity Foundation",
            companyURL: "https://sovrin.org"
          },
          {
            name: "Mike Varley",
            url: "https://github.com/mavarley",
            company: "SecureKey",
            companyURL: "https://securekey.com"
          },
          {
            name: "Devin Fisher",
            url: "https://github.com/devin-fisher",
            company: "Evernym",
            companyURL: "https://evernym.com"
          },
          {
            name: "Tobias Looker",
            url: "https://github.com/tplooker",
            company: "Mattr",
            companyURL: "https://www.mattr.global"
          },
          {
            name: "Kyle Den Hartog",
            url: "https://github.com/kdenhartog",
            company: "Mattr",
            companyURL: "https://www.mattr.global"
          }
        ],
        processVersion: 2017,
        edDraftURI: "https://github.com/openssi/peer-did-method-spec",
        shortName: "peer-did-method",
        subtitle: "A blockchain-agnostic decentralized identifier method",
        github: "https://github.com/openssi/peer-did-method-spec",
        wg: "greater SSI community",
        pluralize: true
      };

    </script>
</head>
<body>

<section id='abstract'>
    <p>This document defines a "peer" <a href="https://w3c-ccg.github.io/did-spec/#specific-did-method-schemes"
        target="didspec">DID Method</a> that conforms to the <a href="https://w3c-ccg.github.io/did-spec/"
        target="didspec">DID Spec</a>. The method can be used independent of any central source of truth, and is
        intended to be cheap, fast, scalable, and secure. It is suitable for most private relationships between people,
        organizations, and things. We expect that peer-to-peer relationships in every blockchain ecosystem can benefit
        by offloading pairwise and n-wise relationships to peer DIDs.</p>
</section>

<section id='sotd'>
    <p>&nbsp;
    </p>
</section>

<section id="intro">
    <h1>Introduction</h1>

    <p>Most documentation about DIDs describes them as identifiers that are rooted in a public source of truth like a
        blockchain, a database, a distributed filesystem, or similar. This publicness lets arbitrary parties <a
                target="_blank" href="https://w3c-ccg.github.io/did-resolution/">resolve</a> the DIDs to an endpoint and
        keys. It is an important feature for many use cases.</p>

    <p>However, the vast majority of relationships between people, organizations, and things have simpler requirements.
        When Alice<code>(</code>Corp<code>|</code>Device<code>)</code> and Bob want to interact, there are exactly and
        only 2 parties in the world who should care: Alice and Bob. Instead of arbitrary parties needing to resolve
        their DIDs, only Alice and Bob do.</p>

    <p>Some formal terminology may make the application of this insight to DIDs clearer:</p>

    <dl>
        <dt><dfn>Anywise</dfn> DID</dt><dd>A DID intended for use with an unknowable number of parties (e.g., the global public
            or some subset thereof).</dd>
        <dt><dfn>Pairwise</dfn> DID</dt><dd>A DID intended to be known by its subject and exactly one other party (e.g., one
            usable in the Alice and Bob example just above).</dd>
        <dt><dfn>N-wise</dfn> DID</dt><dd>A DID intended to be known by exactly <em>N</em> enumerated parties including
            its subject. A business partnership with 3 members might be a modeled with n-wise DIDs. Pairwise DIDs are
            just a special case of an N-wise DID (<em>N</em> = 2). For more on n-wise DIDs, see <a href="nwise.html">
            N-Wise Semantics</a>.</dd>
    </dl>

    <p>Generally, an anywise DID needs to be resolvable by strangers. These strangers can use the DID to reference its
        subject without establishing a relationship. On the other hand, pairwise and n-wise DIDs only need to be
        resolvable by the parties in the relationship, and <em>each</em> party in the relationship has to contribute a
        DID to make the relationship work. Because of the reciprocal nature of DID usage in enumerated relationships
        like this, we call the parties "peers", and it is this dynamic that gives our DID method its name.
    </p>

    <section>
        <h3>Guarantees</h3>
        <p>This spec uses a <a target="aries"
        href="https://github.com/hyperledger/aries-rfcs/blob/master/concepts/0003-protocols/README.md#what-is-a-protocol">
            protocol</a>, rather than a public oracle, as the root of trust. This protocol reliably communicates data
            about peer DIDs and peer DID Docs; peers must persist that data into a local cache or database that functions
            as the <a target="didspec" href="https://w3c-ccg.github.io/did-spec/#dfn-dir">Decentralized Identifier
            Registry</a> for the method. The method is worthy of trust because it guarantees the following properties:
        </p>
        <dl>
            <dt>DIDs are associated with at least one key pair at the moment of creation.</dt>
            <dd>This prevents a category of man-in-the-middle attacks where an attacker could rotate a DID's keys
                at the outset of a relationship, unbeknownst to peers.
            </dd>
            <dt>DIDs have an acceptable level of uniqueness.</dt>
            <dd>This is NOT a guarantee that DIDs will never be reused by their owner, NOR is it a guarantee that
                collusion cannot subvert uniqueness. Thus, it is not a uniqueness upon which deep trust can be based.
                Rather, it is a guarantee that good behavior will not produce accidental collisions. In this
                sense, it is a bit like the uniqueness offered by NATing mechanisms in IPv4. It provides
                enough uniqueness that a DID can be used as an index in a database or as a routing target
                in DID communication. It also makes it possible for blockchains to <a href="#grafting">graft</a> a peer
                DID by mapping it into their namespace, without incurring the risk of ambiguity. Any time a peer
                DID is discovered to be less than unique, a true problem exists and systems can fairly
                raise an exception.
            </dd>
            <dt>The values of DIDs are securely random.</dt>
            <dd>This prevents attackers from discovering patterns in DIDs that might undermine privacy.
            </dd>
            <dt>Parties to a relationship can prove the orderly and authorized evolution of their
                keys to one another.</dt>
        </dl>
    </section>
    <section>
        <h3>Advantages</h3>
        <p>Peer DIDs are not suitable for <a>anywise</a> use cases, which are usually public by intent. However, peer
            DIDs have certain virtues that make them desirable for private relationships between a small number of
            enumerable parties:</p>
        <ul>
            <li>They have no transaction costs, making them essentially free to create, store, and maintain.</li>
            <li>They scale and perform entirely as a function of participants, not with any central system's capacity.</li>
            <li>Because they are not persisted in any central system, there is no trove to protect.</li>
            <li>Because only the parties to a given relationship know them, there is no concern about personal data and
                privacy regulations due to third-party data controllers or processors.
            </li>
            <li>Because they are not beholden to any particular blockchain, they have minimal political or technical
                baggage.
            </li>
            <li>They can be mapped into the namespaces of other DID ecosystems, allowing a peer DID to have
                predictable meaning in 1 or more other blockchains. This solves a problem with blockchain forks
                fighting over the ownership of a DID and promotes interoperability.
            </li>
        </ul>
    </section>
    <section>
        <h3>Comparison to Other DID Methods</h3>
        <p>We could certainly build peer relationships with <a>anywise</a> DIDs based on a public ledger or a similar
            source of truth. However, in the same way that a company doesn't want the public to resolve private host
            names inside its corporate intranet, letting others resolve <a>pairwise</a> and <a>n-wise</a> DIDs is
            unnecessary, and it represents a privacy and security risk as well as a problem of cost, scale, and
            performance. We strongly recommend that peer DIDs be used for peer relationships.
        </p>
        <p>In a similar vein, peer DIDs could be used, hypothetically, for <a>anywise</a> scenarios. The main
            disadvantage would be the lack of a formal publication mechanism. Nothing would prevent a user from
            publishing a peer DID and its associated DID Document on some website, but such publication would be hard to
            discover, maintain as DID Docs evolved, and integrate into interoperable applications. DID methods that use
            a public ledger or a similar source of truth are a better choice here, because they have authoratitive
            answers to the publication problem.
        </p>
    </section>
    <section>
        <h3>Applicability in Group Relationships</h3>
        <p>Most of this doc is framed by a <a>pairwise</a> Alice:Bob context. This sort of pair (no matter whether its
            members are people, IoT devices, or institutions) will be the most common peer relationship in the SSI
            landscape. Groups larger than 2 can also have a peer-style relationship&mdash;but not all groups will be
            modeled that way. Therefore, applying this method to groups should be done thoughtfully.</p>
        <p>Some groups, such as a doctor, a hospital, and a patient participating in a medical procedure together, are
            <a href="nwise.html#sweet-spot">clearly n-wise</a>. Each party can enumerate all the other parties, and each
            party uses the same identifier in all directions within the group:
        </p>
        <img src="n-wise.png"/>
        <p>(See <a href="https://github.com/hyperledger/aries-rfcs/blob/master/concepts/0006-ssi-notation/README.md"
            target="aries">Aries RFC 0006</a> for help with the notation used in the diagram.)</p>
        <p>But groups can also be modeled with a hub-and-spoke model. That model is commonly used in group chats,
            for example: each member of the group chat sends and receives via a central service, which in turn
            broadcasts to all other members of the group. This hub-and-spoke model is actually just a <a>pairwise</a>
            variant, because the relationship is between a member and the hub; all other relationships are only
            indirect:</p>
        <img src="hub-wise.png"/>
        <p>Use of peer DIDs with <a>n-wise</a> groups is explicitly supported and documented below. We do not cover
            hub-and-spoke groups in the same way. They are compatible with this method, if reanalyzed as
            <a>pairwise</a>. Otherwise, the protocol described here may need adaptation.</p>
    </section>
    <section>
        <h3>Enforcement</h3>

        <p>In centralized systems, security is enforced at the center. This is so obvious that we take it for
            granted&mdash;you can't access a database unless you log in first, and it's the database that enforces
            this.
        </p>
        <p>Despite their other decentralized features, blockchains are no different in this respect. If a
            blockchain accepts updates to a DID Doc, then the blockchain must guarantee that those updates are
            only made by authorized parties. Thus, most DID methods imagine a blockchain parsing the
            authorization section of a DID Doc, and rejecting mischief from hackers.
        </p>
        <p>However, in a peer relationship, there IS no centralized authority. This leads to an interesting
            inversion of responsibility that must be understood: Bob enforces Alice's <a href="#authorization">
            authorization policy</a>, and Alice enforces Bob's.
        </p>
        <p>This might seem wrong&mdash;shouldn't Alice enforce her own security? But it is quite rational. Who cares
            whether the agents he is dealing with truly belong to Alice and are authorized by her? Bob does.
            And if one of Alice's agents gets hacked and attempts to subvert the Alice:Bob relationship,
            who is the uncontaminated party that can refuse to cooperate with the rogue agent? Bob is.
        </p>
        <p>Another way to think about this is that, within the Alice:Bob relationship, Bob acts as a substitute
            for a centralized resource that Alice's agents try to access. In such a mental model, of course, Bob
            would be a logical place to enforce access rules for Alice.
        </p>
    </section>
</section>

<section id="core">
    <h2>Core Characteristics</h2>
    <section>
        <h3>Namestring</h3>
        <p>The namestring that shall identify this DID method is: <code>peer</code></p>
        <p>A DID that uses this method MUST begin with the following prefix: <code>did:peer:</code>.
            Per the DID specification, this string MUST be in lowercase. The remainder of the DID, after the prefix,
            is the <a href="#namespace-specific-identifier-nsi">namespace specific identifier specified below</a>.
        </p>
        <p>Early feedback on this method suggested that we embed it beneath the namespace of a particular blockchain,
            as in <code>did:sov:peer</code> or <a
                    target="_blank" href="https://w3c-ccg.github.io/didm-veres-one/#veres-one-did-format"><code>did:v1:nym</code></a>.
            However, this DID method is not captive to any particular blockchain, does not take its resolution rules
            from a parent method, and does not require anchoring or reference to a blockchain to be valid.
            Furthermore, any direct or indirect anchoring of a peer DID to a specific blockchain is driven by
            circumstance and changeable at any time. For example, a peer DID could specify that it is using
            a dead drop on blockchain 1, then change to blockchain 2, then change to blockchains 3 and 4 at
            the same time. Therefore, "peer" belongs at the top of the DID namespace. How this method may be
            used in conjunction with various blockchains is discussed <a
            href="#grafting">later</a>.
        </p>
    </section>
    <section>
        <h3>Target System(s)</h3>
        <p>This DID method applies to any identity management implementation that meets the following two
            requirements:</p>
        <ul>
            <li><em>Generation Algorithm</em> &mdash; The DIDs are created using the <a href="#namespace-specific-identifier-nsi">
                algorithm described below</a>, endowing them with properties vital to trust between peers that is not
                dependent on a central source of truth.
            </li>
            <li>
                <em>Protocol</em> &mdash; The metadata for DIDs (what would be stored in an on-chain DID Doc in other methods)
                is communicated and maintained as described in the <a href="#protocols">Protocols</a> section.
            </li>
        </ul>
    </section>
    <section>
        <h3>Namespace Specific Identifier (NSI)</h3>
        <p>The Peer DID scheme is defined by the following <a target="rfc" href="https://tools.ietf.org/html/rfc5234">
            ABNF</a>:</p>
<blockquote>
    <code>
        peer-did = "did:peer:" version "-" idstring<br>
        version = "1"<br>
        idstring = multibase multihash<br>
        multibase = "F"</code> <span style="color:green"># See hex in
                <a target="multibase" href="https://github.com/multiformats/multibase">multibase spec</a></span><br>
    <code>multihash = "1220" restofhash</code> <span style="color:green"># See sha256+hex in
                <a target="multihash" href="https://multiformats.io/multihash/">multihash spec</a></span>
</blockquote>
        <p>Peer DIDs use an underlying number with high entropy, called the <dfn>numeric basis</dfn>, as the
            source of their uniqueness. This version of the spec (<code>version</code>
            == <code>1</code>) generates the numeric basis from a hash of the initial content
            of a DID Doc (see next section). Subsequent versions of the spec may describe
            additional generation methods as needed.</p>
        <p>This <em>numeric basis</em> is encoded as a hash using the
            <a target="multihash" href="https://multiformats.io/multihash/">multihash prefix</a>
            for sha256+hex: "1220". Although this prefix is redundant today, a multihash prefix is used
            so that a different digest or encoding may be selected in the future.</p>
        <p>The multihash value is preceded by a <a target="multibase"
                href="https://github.com/multiformats/multibase">multibase prefix</a> that tells how to
            interpret the multihash that follows. Since the multihash value is hex in
            this version of the spec, <code>multibase</code> is always "F" today; if the
            multihash variant changes in the future, <code>multibase</code> may, too.
        <p>
        <p>Peer DIDs must be compared according to whatever case-sensitivity is implied by the
            hash encoding they use. Hex is not case-sensitive, but if a future version of the spec
            uses base58 or base64 encoding, values will be case sensitive. Therefore, it is required
            that routines that handle peer DIDs not normalize case unless they take into account the
            specific hash encoding.</p>
    </section>
    <section>
        <h3>Namestring Generation Method</h3>
        <p>The unique <em>numeric basis</em> underlying a Peer DID MUST be generated as follows:</p>
        <ul>
            <li>Create a <dfn>genesis version</dfn> of the DID Doc for the DID. The genesis version MUST include
                enough state that the genesis version of the doc can be signed, to prevent man-in-the-middle
                attacks during initial DID exchange. It SHOULD also include enough state that subsequent
                evolutions to the doc are authorized; otherwise, the doc is a dead end.
                It MUST NOT include DID value itself (the root <code>id</code> key and value of the DID document). This
                lets the doc be created without knowing the DID's value in advance, solving a chicken-and-egg problem.
                Suppressing the DID value creates a variant of the peer DID doc known as the <dfn>stored variant</dfn>,
                as opposed to the <dfn>resolved variant</dfn> that would have an actual DID value in the root <code>id
                </code> property. (In either the stored or resolved variant of the doc, anywhere else that the DID value
                would appear, it should appear as a relative reference rather than an absolute value. For example, each
                <code>controller</code> property of a <a href="#publickey">publicKey that is owned by this DID would say
                <code>"controller": "#id"</code></a>.)
            </li>
            <li>Calculate the SHA256 hash of the bytes of the <a>stored variant</a> of the DID Doc, and assign it
                as the DID's <a>numeric basis</a>.
            </li>
        </ul>
        <p>By basing the numeric value of the DID on the <a>genesis version</a> of the DID Doc, the DID can begin its
            lifecycle with any number of keys and endpoints, and when the doc is signed or auth-encrypted by one
            of the keys, the recipient can know it has not been modified since creation. This guarantees the
            initial integrity of the DID's chain of custody.</p>
        <p>By hashing the stored variant, we avoid the circular problem of including the DID in the data that's being
            hashed. This means that a peer DID doc must be resolved by converting the <a>stored variant</a> into a
            <a>resolved variant</a> by inserting the value of the DID being resolved, during resolution.</p>
    </section>
    <section>
        <h3>Examples</h3>
        <p>A convenient regex to match <code>peer</code> DIDs is:</p>
        <blockquote>
            <code>^did:peer:1-F1220[a-fA-F0-9]{8,40}$</code>
        </blockquote>
        <p>A valid <code>peer</code> DID might be:</p>
        <blockquote>
            <code>did:peer:1-F1220479cbc07c3f991725836a3aa2a581ca2029198aa420b9d99bc0e131d9f3e2cbe</code>
        </blockquote>
        <p>Examples of a DID Doc for this method are explored in greater detail <a href="#did-doc-structure">below</a>.</p>
    </section>
</section>

<section id="protocols">
    <h2>Protocols</h2>
    <section>
        <h3>Roles and Agents</h3>

        <p>As described in the introduction, we call this the "peer" DID method because it enables peers to exchange
            DIDs without recourse to a central authority. Thus, we expect all participants in the protocol to play the
            same <code>peer</code> role, and to operate by exactly the same rules. And this is the case, at a high
            level.
        </p>

        <p>However, at another level of detail, each peer may interact through various pieces of software
            and hardware that proxy them. They may need to reveal a modest amount of information about such <a
            target="aries" href="https://github.com/hyperledger/aries-rfcs/blob/master/concepts/0004-agents/README.md">
            agents</a> to achieve cooperative security. For example, Alice may control 3 devices and may wish to protect
            herself from hacking by saying that at least 2 of her existing devices must agree before a new device can be
            added or an existing device can be revoked. This requires her to share her M-of-N <a href="#authorization">
            authorization policy</a> with Bob, with enough information about agent keys that he can validate a multi-party
            digital signature. Thus, our protocol must occasionally contemplate details about this more granular level
            of each peer's <a target="glossary"
            href="https://docs.google.com/document/d/1gfIz5TT0cNp2kxGMLFXr19x1uoZsruUe_0glHst2fZ8/edit#heading=h.pufsrf9ucjvv">
            sovereign domain</a>.
        </p>
    </section>

    <section>
        <h3>Messages</h3>
        <dl>
            <dt>Peers interact via messages.</dt>
            <dd>This is a more general claim than saying that peers expose an API because it doesn't assume that peers
                are directly callable by each other. It must be possible to exchange DIDs in this method in a very
                asynchronous fashion (e.g., one party sends a message while the other party is offline; a response is
                returned when the original sender may not be actively listening).
            </dd>
            <dt>Message transmission is transport-agnostic.</dt>
            <dd>That is, the messages can flow over any combination of HTTP, Bluetooth, NFC, email, AMPRNet (TCP/IP over
                ham radio), snail mail, sneakernet, intermediaries, or future protocols we have not yet imagined.
            </dd>
            <dt>Messages are <a target="rfc" href="https://tools.ietf.org/html/rfc8259">JSON</a>.</dt>
            <dd>They are compatible with <a target="jsonld" href="https://w3c.github.io/json-ld-syntax/#basic-concepts">
                basic concepts of JSON-LD</a>, but <a target="jsonld"
                    href="https://github.com/hyperledger/aries-rfcs/blob/master/concepts/0047-json-ld-compatibility/README.md">
                no deep knowledge of JSON-LD is required to understand them, and no dependency
                on JSON-LD libraries is necessary</a>. The specifics of the JSON format are discussed below.
            </dd>
            <dt>Messages are serialized and encrypted in a standard way for transport.</dt>
            <dd>
                <p>This method associates security guarantees with the message envelope rather than the transport, and is
                aligned philosophically with the approach of <a href="https://datatracker.ietf.org/wg/mls/about/"
                target="rfc">IETF's Message Level Security initiative</a>. However, the first version of this spec
                predates MLS's maturity, so the wire format uses <a href="https://www.rfc-editor.org/rfc/rfc7516.txt"
                target="rfc">JWEs</a> with <a href="https://github.com/openssi/peer-did-method-spec/issues/14#issuecomment-493626810"
                target="_blank">some extensions</a>, instead. The extensions allow the same message to be
                encrypted once for multiple recipients and sent to them all in an efficient manner:
                </p>
                <img src="multiplex.png"/>
                <p>These extensions are under review by the maintainers of JWE/JWT and are likely to be mainstreamed
                    eventually. The particulars are detailed in <a target="aries"
                    href="https://github.com/hyperledger/aries-rfcs/blob/master/features/0019-encryption-envelope/README.md">
                    a doc</a> that explains how agents in the Hyperledger Aries ecosystem have implemented the format -
                    but the format is easy to implement without any Aries dependencies, and its design has no connection
                    to any particular blockchain. See <a href="https://github.com/dbluhm/indy-pack-unpack-js/blob/db9d83e4/index.js"
                    target="_blank">this implementation in pure javascript</a>, and
                    <a href="https://github.com/bcgov/indy-catalyst/blob/bba2ef5c/agent/indy_catalyst_agent/wallet/crypto.py#L402"
                    target="_blank">this one in pure python</a>, in addition to
                    <a target="_blank" href="https://github.com/hyperledger/indy-sdk/blob/fbad7422/libindy/src/api/crypto.rs#L634">
                    Indy's C-callable implementation in Rust</a>.
                </p>
            </dd>
        </dl>
    </section>

    <section>
        <h3>CRUD Operations</h3>
        <section>
            <h4>Create (Register)</h4>
            <p>Although the work of <em>creating</em> a peer DID and the <a>genesis version</a> of its DID Doc can be
                done at any time and does not require a message,<em>registering</em> a peer DID with the other party or
                parties in a relationship involves a specific sequence of messages known as the <dfn>DID Exchange
                protocol</dfn>. The protocol is <a target="aries"
                href="https://github.com/hyperledger/aries-rfcs/blob/master/features/0023-did-exchange/README.md">
                    formally documented in Aries RFC 0023</a>; only a summary is offered here. It has 3 steps:</p>
            <ol>
                <li>One of the parties (the <dfn>inviter</dfn>) sends an <dfn>invitation</dfn> to connect. The
                    invitation is NOT encrypted, and it does NOT require the recipient (the <dfn>invitee</dfn>) to
                    have special software that understands this protocol. Instead, it is a specially formatted URI
                    that can be a deep link, helping the invitee to learn about SSI, get an SSI-capable app, and
                    otherwise onboard into the ecosystem. If the invitee already has SSI-aware software, the URI
                    can be recognized by a registered handler, short-circuiting the URI fetch and the onboarding/
                    learning process. This invitation URI may be transmitted by email, SMS, QR code, or any other
                    convenient method. If it is important to the inviter that it be secured, the inviter can share
                    the invitation on a secure channel.
                </li>
                <li>The invitee sends an encrypted <dfn>connection request</dfn> back to the inviter, using the
                    endpoint that the inviter supplied in the invitation. This connection request includes the
                    invitee's genesis DID Doc, DID, and keys.
                </li>
                <li>The inviter sends an encrypted <dfn>connection response</dfn> the other direction. This response
                    includes the inviter's genesis DID Doc, DID, and keys.
                </li>
            </ol>
            <p>These three steps have been carefully defined to achieve a number of important goals:</p>
            <ul>
                <li>Because the invitation can be sent to someone who does not know about DIDs or SSI at all,
                    and because it can be sent over insecure channels, establishing DID relationships has an
                    extremely low bar. This is vital to the virality of SSI.
                </li>
                <li>The invitation identifies an endpoint over which the connection can occur, but it does not
                    communicate peer keys or a peer DID from the inviter, and the endpoint that the inviter uses (as
                    well as the inviter's DID and keys) are only transmitted once security and privacy are guaranteed.
                </li>
                <li>The protocol can be used by parties using any DID method. One of the parties can be using
                    a peer DID, both can, or neither can.
                </li>
                <li>The invitation can be sent by a third party, allow introductions (Alice introduces Carol to Bob).
                    However, an introducer is prevented from seeing the secure and private connection built by the
                    two parties.
                </li>
            </ul>
            <p>Additional security against man-in-the-middle attacks may be achieved by signing an invitation, if it is
                public. If the public invitation includes an anywise DID, then the invitee should verify that a
                signature the inviation matches with an active verification key for the associated anywise DID. If the
                public invitation includes a verification key, then the invitee can verify that the signature on the
                invitation matches with the verification key. Once the pair of Peer DID is established, the invitee can
                ask the inviter for proof-of-control of that initial verification key. In any case, further action is
                advisable to build deeper trust about the identity of other side. This likely includes mutual exchange
                of <a target="vcspec" href="https://w3c.github.io/vc-data-model/">verifiable credentials</a>.
            </p>
        </section>

        <section>
            <h4>Read (Resolve)</h4>
            <p>This operation, as well as Update and Delete, are documented in greater detail in
                <a href="https://github.com/hyperledger/aries-rfcs/blob/master/features/0030-sync-connection/README.md"
                target="aries">Aries RFC 0030</a>. Here, we offer only a summary.
            </p>
            <p>A peer DID can be resolved to a DID Document by sending a <a target="aries"
            href="https://github.com/hyperledger/aries-rfcs/blob/master/features/0030-sync-connection/README.md#state_request">
            state_request</a> message from one peer to another:</p>
            <pre class="example" title="Sample state_request message">
{
  "@type": "did:sov:BzCbsNYhMrjHiqZDTUASHg;spec/sync_connection/1.0/state_request",
  "@id": "6a4986dd-f50e-4ed5-a389-718e61517207",
  "for": "did:peer:1-F1220479cbc07c3f991725836a3aa2a581ca2029198aa420b9d99bc0e131d9f3e2cbe",
  "as_of_time": "2019-07-23 18:05:06.123Z"
}
            </pre>
            <p>The <code>as_of_time</code> property is optional and often omitted; if so, the DID Doc at
                the current time is returned.</p>
            <p>A
                <a href="https://github.com/hyperledger/indy-hipe/blob/826ce818/text/conn-mgmt-protocols/README.md#state_response"
                target="aries">state_response</a> message is returned. It includes a DID Doc and some additional
                metadata, and looks like this:
            </p>
            <pre class="example" title="Sample state_response message">
{
  "@type": "did:sov:BzCbsNYhMrjHiqZDTUASHg;spec/sync_connection/1.0/state_response",
  "@id": "1517207d-f50e-4ed5-a389-6a4986d718e6",
  "~thread": { "thid": "6a4986dd-f50e-4ed5-a389-718e61517207" },
  "for": "did:peer:1-F1220479cbc07c3f991725836a3aa2a581ca2029198aa420b9d99bc0e131d9f3e2cbe",
  "did_doc": { ...full content of either the resolved variant of DID Doc... },
  "as_of_time": "2019-07-23 18:05:06.123Z"
}
            </pre>
            <p class="note">Note the use of <code>~thread</code> in the response, with <code>thid</code> equal to the
                <code>@id</code> property of the previous request, to connect the two messages. This is a
                <a target="aries"
                href="https://github.com/hyperledger/aries-rfcs/tree/master/concepts/0008-message-id-and-threading#threaded-messages">
                standard message threading feature of DID Communication</a>, and also shows up in other
                message interactions described here.</p>
        </section>

        <section>
            <h4>Update</h4>
            <p>The subject of a peer DID can update their associated DID Document with anyone who knows the
                DID&mdash;one or more agents of the peer, or agents of the owner itself&mdash;by sending a <a target="aries"
                href="https://github.com/hyperledger/indy-hipe/blob/826ce818/text/conn-mgmt-protocols/README.md#state_response">
                sync_state</a> message to another peer. An example of this type of message is:</p>

            <pre class="example" title="Sample sync_state message">
{
  "@type": "did:sov:BzCbsNYhMrjHiqZDTUASHg;spec/sync_connection/1.0/sync_state",
  "@id": "e61586dd-f50e-4ed5-a389-716a49817207",
  "for": "did:peer:1-F1220479cbc07c3f991725836a3aa2a581ca2029198aa420b9d99bc0e131d9f3e2cbe",
  "base_hash": "d48f058771956a305e12a3b062a3ac81bd8653d7b1a88dd07db8f663f37bf8e0",
  "base_hash_time": "2019-07-23 18:05:06.123Z",
  "deltas": [
    {
      "ops": [
        {
          "op": "add_key",
          "fragment": {
            "id": "6", "type": "Ed25519Verkey2018",
            "owner": "did:peer:1-F12203f991725836a3aa2a5479cbc07c81ca2029198aa420b1d9f3e2cbe9d99bc0e13",
            "publicKey": "DjbU8jgf1MjGWu6hGwr4N4EoAfhfTjutjWc8fgdxb3QP"
          }
        },
        {
          "op": "remove_key",
          "fragment": {"id": "5"}
        }
      ],
      "delta_time": "2019-07:23 19:00:01",
      "result_hash": "058771956a305e12a3b062a3ac81d48fbd8653d7f663f37bf8e0b1a88dd07db8",
      "proofs": [
        {
          "by": "#4",
          "signature": "MIIB6gYJKoZIhvcNAQcCoIIB2zCCAdcCAQE...wYDVQQKEwR"
        }
      ]
    }
  ]
}
                </pre>
            <p>This message does not follow a simple request~response pattern, and does not have "update" in its name,
                because either party may know details that the other party lacks. This is especially likely when some
                agents of either party have been offline. The sender picks a point in time, <code>delta_time</code>,
                where it believes it and the receiver were probably in sync; it then describes the <a target="aries"
                href="https://github.com/hyperledger/aries-rfcs/tree/master/features/0030-sync-connection#did-doc-deltas">
                deltas</a> that it knows about, that have happened since.
            </p>
            <p>If the recipient already has the same state, it replies with an <a target="aries"
                    href="https://github.com/hyperledger/aries-rfcs/blob/master/features/0015-acks/README.md">ACK</a>.
            </p>
            <p>If the recipient knew about a subset of the delta, but not all of it, it applies what is left of the
                delta, and sends an ACK.
            </p>
            <p>If the recipient has a more evolved state, the recipient sends a reply that is a new <code>sync_state
            </code> message informing the sender of hitherto unknown information. As with the ACKs, this new message is
                known to be a reply to the original <code>sync_state</code> because its <a target="aries"
                href="https://github.com/hyperledger/aries-rfcs/tree/master/concepts/0008-message-id-and-threading#threaded-messages">
                <code>~thread</code> decorator identifies the previous message's <code>@id</code> as its
                <code>thid</code></a>.
            </p>
            <p>If the recipient does not recognize the base_hash, it selects a hash from a point in time earlier than
                <code>base_hash_time</code> and sends back a new <code>sync_state</code> message with that earlier base.
            </p>
            <p>If the recipient detects a conflict, it attempts to merge states. If the merge is successful, it sends a
                new <code>sync_state</code> that shows the merge. If the merge is not successful, then a merge
                conflict exists, and the merge conflict policy for the sovereign domain of the associated DID is
                invoked. See <a target="aries"
                href="ttps://github.com/hyperledger/aries-rfcs/tree/master/features/0030-sync-connectiong#merges-and-merge-conflicts">
                    "Merges and Merge Conflicts"</a>.
            </p>
        </section>

        <section>
            <h4>Delete</h4>
            <p>In a self-sovereign paradigm, abandoning a relationship can be done unilaterally, and does not
                require formal announcement; one party can simply stop communicating with the other. Since there
                is no public record of the relationship to delete, no further action is strictly required.
                Indeed, sometimes a formal announcement is impossible, if one of the parties
                is offline.</p>

            <p>However, it is best practice to announce that the relationship is being abandoned. This
                should cause the other party to clean up by removing the DID, DID Doc, and associated metadata from its
                local cache. It should also prevent the other party from trying to communicate in the future.
                Formally terminating a connection happens by sending a <a target="aries"
                href="ttps://github.com/hyperledger/aries-rfcs/tree/master/features/0030-sync-connection#leave"><code>
                leave</code> message</a> to a peer:</p>
            <pre class="example" title="Sample leave message">
{
  "@type": "did:sov:BzCbsNYhMrjHiqZDTUASHg;spec/sync_connection/1.0/leave",
  "@id": "c17147d2-ada6-4d3c-a489-dc1e1bf778ab",
  "~please_ack": {}
}
            </pre>
            <p>If Bob receives a message like this, he should assume that Alice no longer considers
                herself connected, and take appropriate action. This could include destroying
                data about Alice that he has accumulated over the course of their relationship,
                removing her peer DID and its public key(s) and endpoints from his wallet, and so
                forth. The nature of the relationship, the need for a historical audit trail, regulatory
                requirements, and many other factors may influence what's appropriate; the protocol
                simply requires that the message be understood to have permanent termination semantics.
            </p>

            <p>The <a target="aries" href="https://github.com/hyperledger/aries-rfcs/blob/master/features/0015-acks/README.md#requesting-an-ack-please_ack">
                <code>~please_ack</code> decorator</a> is optional. It asks the receiver to send an acknowledgement that
                it has processed the message. If used, the receiver should send an ACK that looks like this:</p>

            <pre class="example" title="Sample ACK">
{
"@type": "did:sov:BzCbsNYhMrjHiqZDTUASHg;spec/sync_connection/1.0/ack",
"@thread": { "thid": "c17147d2-ada6-4d3c-a489-dc1e1bf778ab" }
}
</pre>
        </section>
    </section>
</section>

<section>
    <h2>DID Doc Structure</h2>
    <section>
        <h3>CRDTs</h3>
        <p>Because peer DID Docs can be updated by multiple parties at the same time (as when two agents rotate their
        keys without coordinating), they have the potential for merge conflicts. Resolving these merge conflicts could
        introduce much complexity in this DID method, but peer DID Docs use a clever technique that avoids the issue
        entirely. The docs are carefully defined in such a way that they are <a target="wikipedia"
        href="https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type">conflict-free replicated data types</a>
        (<dfn>CRDTs</dfn>).</p>
        <p>CRDTs are a deep subject unto themselves, and additional study on the web is recommended. Here, we will
            simply note some key requirements that they impose on DID Doc structure.</p>
        <ol>
            <li>Core building blocks of DID Docs&mdash;keys, rules, and service endpoints&mdash; must be assigned
                <code>id</code> properties in a way that prevents collisions.</li>
            <li>Lists of these core building blocks must be paired with a corresponding <dfn>deletion list</dfn>. These
                are lists of strings that contain the <code>id</code>s of deleted items. Deletion is irreversible, in
                that items written to this list can never be removed. An <code>id</code> that appears in a deletion
                list SHOULD NOT also appear in <code>publicKey</code>, but even if it does, it is unusuable.</li>
            <li>All identified items must be considered immutable. Although we can casually speak of operations like
                key rotation or rule changes as if they were in-place edits, edits must actually be modeled by an
                implementation as the deletion of an old item and the insertion of a new one.</li>
            <li>When any party encounters two versions of a peer DID doc, one of which has an item in undeleted state and
                one of which has the item in a deleted state, the item's state should be considered deleted, regardless
                of relative timing of the two versions. This eliminates the possibility that a malicious party could
                attempt to take advantage of differences in system clocks or sequencing.</li>
        </ol>
        <p>Details about CRDT requirements are documented below, in the sections about individual parts of the DID Doc.
            These will make the CRDT semantics and the technique clearer.</p>
    </section>
    <section>
        <h3><code><dfn>publicKey</dfn></code></h3>
        <p>The <code>publicKey</code> section of a peer DID document is as you would expect from a reading of the
            <a target="didspec" href="https://w3c-ccg.github.io/did-spec/#authentication">DID spec</a>. Peer DID Docs
            MUST do all of their key definition in this section, even though the DID spec permits some DID methods to
            allow inline definitions in the <code>authentication</code> and <code>authorization</code> sections of a DID
            Doc.
        </p>
        <p>All <code>id</code> properties associated with a key defined internally in the DID Doc MUST be in
            relative, not absolute form (that is, "#xyz" instead of "did:peer:abc#xyz"). IDs for keys defined
            interally may be generated in either of these two ways:
        </p>
        <ul>
            <li>The first 8 characters of the key's unique representation may be used as the <code>id</code>, if this
                provides enough uniqueness within the document. (Global uniqueness is irrelevant.) For example, if the
                key is defined with a <code>publicKeyBase58</code> property value that begins with <code>H3C2AVvL</code>,
                then its <code>id</code> would be <code>H3C2AVvL</code>; a key with a <code>publicKeyHex</code> property
                that begins with <code>02b97c30</code> would have an <code>id</code>of <code>02b97c30</code>, and a key
                with a <code>publicKeyPem</code> property that begins, after its <code>-----BEGIN PUBLIC KEY</code>
                delimiter, with the value <code>izfrNTmQ</code>, would have an <code>id</code> of <code>izfrNTmQ</code>.
                </li>
            <li>A <a target="rfc" href="https://tools.ietf.org/html/rfc4122">standard 128-bit UUID of type 1, 2, 3, 4,
                or 5</a>, rendered with hyphens and in lower case (as required by the UUID RFC), may be used as the
                <code>id</code> instead.</li>
        </ul>
        <p class="note">All IDs in DID Docs, including these, should be considered case-sensitive. Ignoring case will result
            in invalid comparisons for key <code>id</code>s based on encodings that are not hex.
        </p>
        <p>Because peer DIDs usually operate independent of global registries, external references (where <code>controller</code>
            is not <code>#id</code>) will probably be rare, with the possible exception of <a target="aries"
             href="https://github.com/hyperledger/aries-rfcs/blob/master/concepts/0046-mediators-and-relays/README.md">
             mediator</a> keys that have the <a>route</a> privilege.
        </p>
        <pre class="example" title="Sample publicKey section">
{
    ...
    "publicKey": [
        {
            "id": "H3C2AVvL",
            "type": "Ed25519VerificationKey2018",
            "controller": "#id",
            "publicKeyBase58": "H3C2AVvLMv6gmMNam3uVAjZpfkcJCwDwnZn6z3wXmqPV"
        }, {
            "id": "02b97c30",
            "type": "Secp256k1VerificationKey2018",
            "controller": "#id",
            "publicKeyHex": "02b97c30de767f084ce3080168ee293053ba33b235d7116a3263d29f1450936b71"
        }, {
            "id": "izfrNTmQ",
            "type": "RsaVerificationKey2018",
            "controller": "#id",
            "publicKeyPem": "-----BEGIN PUBLIC KEY\r\nizfrNTmQ...END PUBLIC KEY-----\r\n"
        }
    ],
    ...
}
        </pre>
        <p>Elliptic curve keys (Ed25519, Secp256) are preferred because the keys are smaller, the number
            of bits of security are greater, and the computations more efficient, than RSA key types.</p>
        <section>
            <h4><code>publicKey~deleted</code></h4>
            <p>The <code>publicKey</code> section is paired with a <code>publicKey~deleted</code> list, which is a sibling
                to <code>publicKey</code> at the root of the document. This list of strings enumerates the <code>id</code>s
                of all keys that have been revoked, rotated, or otherwise removed from the document. Any time a key is
                added to <code>publicKey~deleted</code>, it should also be removed from <a href="#example-9-sample-authorization-section">
                <code>authorization.profiles</code></a>. An example of a <code>publicKey~deleted</code> list might be:
            </p>
            <pre class="example" title="Sample publicKey.deleted section">
{
    ...
    "publicKey~deleted": ["izfrNTmQ", "e3080168"]
    ...
}
            </pre>
        </section>
    </section>
    <section>
        <h3><code><dfn>authentication</dfn></code></h3>
        <p>The <code>authentication</code> section of a peer DID document conforms to <a target="didspec"
                href="https://w3c-ccg.github.io/did-spec/#authentication">standard practice described in the DID spec</a>,
            with the constraint that only references, not inline key definitions, are allowed. Any keys referenced
            here may be used to authenticate or login as the DID.
        </p>
        <p>However, the meaning of "authenticate" or "login" deserves comment, because there is a tendency in DID
            circles to reference too many keys in this section, and because heavy use of this section is discouraged
            with peer DIDs.
        </p>
        <p>A sovereign domain (the scope of things under the control of a single, sovereign identity owner) may include
            keys that represent the identity owner with greater or lesser degrees of trust. For example, the
            identity owner may hold one key on paper, locked in a safe; she may hold another key on a mobile device's
            secure enclave, protected by a biometric; she may hold a third on a server in a config file protected
            only by an ACL. These keys may all be legitimate evidence that the DID subject is interacting, but
            they are not equally strong evidence. Only the strongest forms of evidence should be accepted as a
            basis for authentication when stakes are high.</p>
        <p>This is not unlike what happens on the political landscape. A low-level diplomat and the president / premier
            / prime minister of a nation are both authentic representatives of their people&mdash;but the scope of their
            privileges, and the concomitant trust, are different. Only the highest-level officials should be signing
            binding international treaties.
        </p>
        <p>The <a href="#authorization"><code>authorization</code> section</a> of peer DID Docs, described next, is
            where fine-grained privileges are described. The <code>authentication</code> section is a blunt instrument,
            incapable of distinguishing between these levels of trust, and incapable of associating trust to anything
            more complex than a single key. It is supported for historical reasons, and because most so-called "DID
            Authentication" use cases assume it will be populated. With peer DIDs, the strong recommendation is that
            only keys held by the most trusted proxies should be referenced here. Only list the equivalent of your
            president / premier / prime minister keys in this section, not the equivalent of keys for your low-level
            diplomats. This will prevent impersonation by less trusted keys when stakes are high.
        </p>
        <section>
            <h4><code>authentication~deleted</code></h4>
            <p>The <code>authentication</code> section is paired with a <code>authentication~deleted</code> list, which
                is a sibling to <code>authentication</code> at the root of the document. This list of strings enumerates
                the <code>id</code>s of all keys that have been removed from the <code>authentication</code> section of the
                document. An example of a <code>authentication.deleted</code> list might be:
            </p>
            <pre class="example" title="Sample authentication.deleted section">
{
    ...
    "authentication.deleted": ["MNam3uVA", "32a769b4-081b-488b-8971-b4eee62f4c94"]
    ...
}
            </pre>
        </section>

    </section>
    <section>
        <h3><code><dfn>authorization</dfn></code></h3>
        <p>Peer DID docs organize their <code>authorization</code> section into two sequences. The first, <code>profiles
        </code>, gives a <dfn>trust profile</dfn> for each key, as expressed by named roles the key holds. These
            named roles are arbitrary strings chosen by the implementer; their meaning in normal language need not
            be understood by a party wishing to understand the semantics.
        </p>
        <p>The second sequence contains <a href="https://evernym.github.io/sgl" target="sgl">SGL</a> rules that grant
            privileges according to named roles. Here is an example that assumes keys with numeric IDs have been defined
            in a preceding <a href="#publickey"><code>publicKey</code></a> section:
        </p>

        <pre class="example" title="Sample authorization section">
“authorization”: {
    "profiles": [
        {"key": "#1", "roles", ["edge"]},              // key #1 is an "edge" key
        {"key": "#2", "roles", ["edge", "biometric"]}, // key #2 is an "edge" and a "biometric" key
        {"key": "#3", "roles", ["cloud"]},             // key #3 is a "cloud" key
        {"key": "#4", "roles", ["offline"]},           // key #4 is an "offline" key
    ],
    "rules": [
        { "grant": ["route", "authcrypt"], "when": {"roles": "cloud"}, "id": "98c2c9cc" },
        { "grant": ["authcrypt", "plaintext", "sign"], "when": {"roles": "edge"}, "id": "e1e7d7bc" },
        {
            "grant": ["key_admin", "se_admin", "rules_admin"],
            "when": {
                "any": [{"roles": "offline"}, {"roles": "biometric"}],
                "n": 2
            }
            "id": "8586d26c"
        }
    ]
}
        </pre>
        <p>In plain english, these rules say:</p>
        <ul>
            <li>Let a key have the "route" and "encrypt" privileges when its set of roles contains "cloud".</li>
            <li>Let a key have the "encrypt" and "decrypt" privileges when its set of roles contains "edge".</li>
            <li>Let any 2 keys, acting together, have the "kadmin" and "eadmin" privileges when their roles each contain
                either "offline" or "biometric".</li>
        </ul>
        <p>Far more elaborate rules could be constructed. See the <a target="sgl" href="https://evernym.github.io/sgl">
            SGL documentation</a> for details.</p>

        <section>
            <h4>Privilege Inventory</h4>
            <p>Unlike role names, the privileges named in these rules DO need to be understood by code that parses peer
                DID Docs; it is these privileges that others in a relationship should enforce. Possible values include:</p>
            <dl>
                <dt><dfn>route</dfn></dt>
                <dd>The holder of this privilege is allowed to receive and decrypt <a target="aries"
                        href="https://github.com/hyperledger/aries-rfcs/tree/master/concepts/0094-cross-domain-messaging#required-mediators-process-forward-messages">
                    DIDComm <code>forward</code> messages</a> encrypted for itself, and to forward the contained
                    <a href="https://github.com/hyperledger/aries-rfcs/blob/master/features/0019-encryption-envelope/README.md"
                            target="aries">DIDComm encryption envelope</a> to another key. Holders of these keys thus become aware
                    of the timing and size of some incoming messages for the recipient (though not of the messages' senders
                    or content). This privilege is required and appropriate for any cloud agent or <a target="aries"
                            href="https://github.com/hyperledger/aries-rfcs/blob/master/concepts/0046-mediators-and-relays/README.md">
                        mediator</a> that exposes a service endpoint on behalf of mobile devices or other agents behind a
                    firewall.</dd>

                <dt><dfn>authcrypt</dfn></dt>
                <dd>The holder of this privilege is allowed to create messages and send them with <a target="wikipedia"
                        href="https://en.wikipedia.org/wiki/Authenticated_encryption">authenticated encryption</a>
                    that reveals the identity of the sender to the reciever. Most agents are likely to have this privilege,
                    but one designed for passive reception only (e.g., on an IoT sensor) might have it removed; doing so
                    would prevent a hacker from co-opting such a key into sending in a trusted way. Messages that are
                    authcrypted by a key that lacks this privilege should be rejected as illegal.</dd>

                <dt><dfn>plaintext</dfn></dt>
                <dd>The holder of this privilege can see <a target="aries"
                        href="https://github.com/hyperledger/aries-rfcs/tree/master/features/0044-didcomm-file-and-mime-types#didcomm-messages-dm">
                    plaintext DIDComm messages</a> intended for an identity owner engaged in a <a target="aries"
                        href="https://github.com/hyperledger/aries-rfcs/blob/master/concepts/0003-protocols/README.md">protocol
                </a>. External parties sending to the owner of a given DIDDoc should multiplex encrypt for all keys that
                    hold this privilege, except in special circumstances.</dd>

                <dt><dfn>sign</dfn></dt>
                <dd><p>The holder of this privilege can incur binding, contractual obligations on behalf of the DID subject.
                    This may actually be a better test for login or authentication, in many cases, than whether a key appears
                    in the <a href="#authentication"><code>authentication</code> section</a> of the DID Doc; it depends on
                    what trust is imputed after login.</p>
                    <p class="note">Any key holder can sign a DIDComm message; doing so gives non-repudiation to the
                        message. However, remember our <a href="#authentication">earlier discussion</a> about low-level
                        diplomats versus the president or prime minister of a country&mdash;both are authentic officials,
                        but only the president or prime minister's signature is binding on an international treaty. This
                        privilege makes explicit that sort of special binding-the-owner status; any other signatures
                        serve to prove origin with a specific agent but not the endorsement of the DID subject.
                    </p></dd>

                <dt><dfn>key_admin</dfn></dt>
                <dd>The holder of this privilege can add or remove other keys from a peer DID Doc's <a href="#publickey">
                    <code>publicKey</code> section</a>, <a href="#authentication"><code>authentication</code> section</a>,
                    or <code>authorization.profiles</code> list. Typically this privilege is held only by very privileged
                    keys, or by combinations of keys, to prevent hackers who co-opt one device from adding new, malicious
                    keys to the inventory.
                </dd>

                <dt><dfn>se_admin</dfn></dt>
                <dd><p>The holder of this privilege can add or remove items from a peer DID Doc's <a href="#serviceendpoint">
                    <code>serviceEndpoint</code> section</a>.</p>
                </dd>

                <dt><dfn>rules_admin</dfn></dt>
                <dd><p>The holder of this privilege can add or remove rules from a peer DID Doc's <code>authorization.rules
                </code> list. Typically this privilege is held only by very privileged keys, or by combinations of keys.</p>
                </dd>

                <dt><code>rotate</code></dt>
                <dd>The holder of this privilege can replace its associated key definition, and all references to that
                    key throughout a DID Doc, with a new key definition and references, in a single delete-and-add
                    operation. If key #2 has this privilege and exercises it, the result is that key #2 is revoked from
                    the doc, but a new key (perhaps key #7) appears with exactly the same profile. This privilege is
                    assumed to be held by all keys unless rules specify otherwise.
                </dd>
            </dl>
        </section>
        <section>
            <h4><code>rules~deleted</code></h4>
            <p>Notice that in the example above, each rule has an <code>id</code> property. This property can be
                assigned in any way that an implementation likes, as long as the values are unique within the document.
                This property is used to maintain a <a>deletion list</a> for the rules. The <code>authorization.rules
                </code> array is paired with a <code>rules~deleted</code> list, which is a sibling to <code>rules</code>
                below <code>authorization</code>. This list of strings enumerates the <code>id</code>s of all rules that
                have been removed from the <code>authorization.rules</code> list. An example of a <code>rules~deleted
                </code> list might be:
            </p>
            <pre class="example" title="Sample authorization.rules~deleted section">
{
    ...
    "authorization": {
        ...
        "rules": [ ... ]
        "rules~deleted": ["rule-1", "32a769b4"]
        ...
    }
    ...
}
            </pre>
            <p class="note">The <code>authorization.profiles</code> section does not have a <a>deletion list</a>.
                This is because the profile of a key is immutable&mdash;it cannot change for the lifetime of a key. Once
                a key is deleted, it is automatically removed from the profiles list (or treated as if it were removed).
            </p>
        </section>
    </section>
    <section>
        <h3><code><dfn>serviceEndpoint</dfn></code></h3>
        <p>This section matches the <a target="didspec" href="https://w3c-ccg.github.io/did-spec/#service-endpoints">
            general description in the DID Spec</a>.</p>
        <section>
            <h4><code>serviceEndpoint~deleted</code></h4>
            <p>Each service endpoint has a unique <code>id</code>. The <code>serviceEndpoint~deleted
            </code> list is thus a list of <code>id</code>s that have been deleted from the <code>serviceEndpoint</code>
            section of the doc, functioning in the same way as other <a>deletion lists</a>.</p>
        </section>
    </section>
</section>

<section class="appendix">
    <h2>Appendix</h2>
    <section>
        <h3>Security Considerations</h3>
        <section>
            <h4>Secure communication</h4>
            <p>All the messages in this protocol (except for a connection invitation that requires no security, by design)
                must be sent encrypted, using the encryption format specified in <a target="aries"
                href="https://github.com/hyperledger/aries-rfcs/blob/master/features/0019-encryption-envelope/README.md">
                DIDComm's encryption envelope</a>. This gives strong guarantees about the confidentiality and integrity of
                exchanged data, regardless of the transport mechanism used to transmit the messages.</p>
        </section>
        <section>
            <h4>Proof of Control</h4>
            <p>Because peer DIDs are generated from an algorithm that includes the values of their initial public key(s)
                as input, they cannot be created without the creator controlling them. As mentioned earlier, this prevents
                man-in-the-middle attacks at the time of creation.
            </p>
        </section>
        <section>
            <h4>Entropy</h4>
            <p>
                Since keys must be created from keys generated by a secure random number generator, they are guaranteed
                to be unpredictable and globally unique at creation time.</p>
        </section>
        <section>
            <h4>Key Management</h4>
            <p>Keys used to control peer DIDs, or keys authorized to communicate and update the DID Docs
                for peer DIDs, should be managed according to best practices for DKMS, as described in
                <a target="aries" href="https://github.com/hyperledger/aries-rfcs/blob/master/concepts/0051-dkms/dkms-v4.md">
                    the DKMS spec</a>.
            </p>
            <p><a target="sgl" href="https://evernym.github.io/sgl/docs/reference.html#rules">SGL rules</a> are powerful and
                flexible, and should be used to implement best practices.</p>
        </section>
        <section>
            <h4>Handling Trust on First Use problem</h4>
            <p>
                The essensce of the the trust on first use problem, is best highlighted by it's 
                <a target="wikipedia" href="https://en.wikipedia.org/wiki/Trust_on_first_use">Wikipedia article</a>. 
                In summary, the TOFU problem is created because it's not possible to verify with only a public key, 
                who is the owner of the private key. This lack of knowledge gives rise to the introduction of MITM attacks.
            </p>
            <p>
                There's two separate ways to handle the TOFU problem with the peer DID method spec. The more common 
                variant is to bootstrap based upon a trusted third party channel. The new approach which is made 
                possible by Verifiable credentials.
            </p>
            <h5>Bootstrap from trusted third party channel</h5>
            <p>
                The core premise of using an out of band channel based solution is to be able to bootstrap the new 
                channel of communication from a third party trusted channel of communication. In many cases this is an 
                adequette solution, and in others it may require additional pieces of information in order to establish 
                trust, such as a verifiable credential exchange.
            </p>
            <p>
                This method has been used in previous systems to rely on in person interactions to verify some piece of 
                information. For example, in some end to end messaging apps, they rely on key fingerprinting which 
                require a use to verify that a key fingerprint sent over a trusted communication channel or viewed in 
                person (usually a number) matches between the two parties. This method allows user to verify that the 
                channel hasn't been Man in the Middle (MITM) attacked.
            </p>
            <p>
                There's also ways that the user experience could be improved using this same security process. For 
                example, a <a target="superuser" href="https://superuser.com/questions/22535/
                what-is-randomart-produced-by-ssh-keygen">randomart image</a> could be embedded into a QR code and then 
                the randomart image could be displayed on the users device as well. The user would then be required to 
                verify the image displayed on the user's device is the same as the one embedded in the QR code. This is 
                a great way to handle short-lived, ephemeral connections such as unlocking a door while being sure the 
                connection has not been MITM attacked.
            </p>
            <h5>Binding Verifiable Credentials with Public keys</h5>
            <p>
                A verifiable credential method is a new approach to bootstrapping trust entirely within the connection. 
                The idea behind this is that a verifiable credential issued by a third party can be combined with a 
                self-attested attribute in a credential proof to link the possession of the key to a verifiable 
                credential.
            </p>
            <p>
                The reason this works is because the blinded secret acts as a coupling mechanism to prove that the owner 
                of the credential is the same as the owner of the public key. If bob detects that the key that Alice 
                provides in the DID Document is different than the key he received in the Credential Proof, than he’s 
                able to detect that some aspect of the setup was done incorrectly or was tampered with. This is good 
                enough indication that Bob SHOULD NOT trust this connection and SHOULD scrap it and reset.
            </p>
            <p>
                One thing of particular importance in this method is that the credential requested must be unique enough 
                such that a malicious party cannot also generate a satisfactory proof. If a malicious party does holder 
                a credential which is not unique enough then the malicious party could conduct a MITM attack. This 
                attack would require a malicious party to first intercept the plaintext DID Document sent in the 
                invitation during the create operation, change the key, endpoint, and signature of the invitation. Then 
                the malicious party must generate a proof that meets the request of the verifier and impersonate the 
                sender.
            </p>
            <p>
                In the majority of security threat models the use of a unique proof which includes all public keys 
                listed in the DID Document as self attested attributes in the proof. As recommendation, a unique proof 
                SHOULD include proof attributes issued by at least 2 unique issuers. This method SHOULD be satisfactory 
                for high value financial transactions while accommdating for internet wide scale. If a threat model 
                needs greater assurances, the parties SHOULD meet in person for a connection setup.
            </p>    
                

        </section>
    </section>

    <section>
        <h3>Privacy Considerations</h3>
        <p>Peer DIDs should remain <a>pairwise</a> or <a>n-wise</a>, not be reused across relationships. This
            allows proper isolation to defeat correlation. It also enables granular exercise of sovereignty in a
            robust, <a target="_blank" href="https://medium.com/evernym/three-dimensions-of-identity-bc06ae4aec1c">
                multidimensional identity</a>.</p>
        <img src="pairwise.png"/>
        <section>
            <h4>Fingerprinting</h4>
            <p>The names of roles and the arrangement of rules in a peer DID doc could conceivably be used to create
            a sort of fingerprint of a sovereign domain, in much the same way that browser fingerprinting keys off
            individual uniqueness in combinations of browser+plugin+hardware configuration. To combat this problem, the
            following best practices are recommended:</p>
            <ul>
                <li>Choose rules from a standard inventory.</li>
                <li>Choose role names from a standard inventory.</li>
                <li>Only define keys that are relevant to a particular relationship.</li>
                <li>Never reuse <code>id</code>s for keys, rules, or service endpoints across DID docs.</li>
            </ul>
        </section>
    </section>

    <section>
        <h3>Grafting</h3>
        <p>Because peer DIDs are globally unique at the moment of creation, their <a>numeric basis</a>
            will not exist on any other blockchain unless someone copies it there. Blockchain-based DID methods can
            therefore (redundantly) register a peer DID Doc using their own method. We call this process <dfn>grafting</dfn>.
            Grafting might be useful when a peer DID needs to be accepted as the submitter or target of a transaction on a
            blockchain, when a blockchain is used as a deaddrop for a peer DID, when it's important to use use existing DID
            tools that assume a global source of truth (e.g., <a href="https://github.com/decentralized-identity/universal-resolver"
            target="_blank">DIF's Universal Resolver</a>), or in other circumstances where a peer DID needs some form
            of partially public reference.</p>
        <p>Grafting can be done either by combining another DID method's prefix with peer DID's NSI (<code>
            "did:peer:1-F1220abcd1234" &mdash;> "did:xyz:1-F1220abcd1234"</code>), or by creating a child namespace for peer
            DIDs beneath another method (<code>"did:peer:1-F1220abcd1234" &mdash;> did:xyz:peer:1-F1220abcd1234"</code>).</p>
        <p>If a peer DID is registered and grafted into another DID namespace, using either method,
            the result is two DIDs with different namespaces, one peer and one anchored, each with
            its own DID Doc. A decision must be made about which DID is normative for the relationship,
            or whether both should continue to be used. If both will be used, it should be understood that
            the two DID Docs hold keys and other data for two different DIDs, regardless of the shared
            history of those DIDs. Ideally, there would be no difference between the DID Docs stored in each place,
            but even with the best intentions of the DID controller, differences may arise.</p>
    </section>

    <section>
        <h3>Reference Implementations</h3>
        <p>The encryption envelop for DID Communication has three independent implementations&mdash;one in
            <a target="_blank" href="https://github.com/hyperledger/indy-sdk/blob/fbad7422/libindy/src/api/crypto.rs#L634">
                libindy</a>, one in
            <a target="_blank" href="https://github.com/bcgov/indy-catalyst/blob/bba2ef5c/agent/indy_catalyst_agent/wallet/crypto.py#L402">
                python with no Indy dependencies</a>, and one in
            <a target="_blank" href="https://github.com/dbluhm/indy-pack-unpack-js/blob/db9d83e4/index.js">
                javascript with no Indy dependencies</a>.</p>
        <p>The connection protocol that creates and registers peer DIDs, including support for DID resolution
            after forming a connection, has been fully implemented by
            half a dozen different organizations, as of March 2019. One of these organizations did not use
            libindy. The connection management protocols that allow update of DIDs are in various states of
            implementation. An up-to-date summary of implementation status, including links to the implementations,
            can be found in the
            <a target="_blank" href="https://github.com/hyperledger/indy-agent">indy-agent repo on github</a>.</p>
        <p>There is a formal test suite for the protocols as well, in the same github repo.</p>
    </section>

    <section>
        <h3>Resources</h3>
        <p>Developers maintaining this spec and its reference implementations are often found on RocketChat at
            chat.hyperledger.org, #aries. You might also connect with them via the Hyperledger Aries mailing list at
            aries@lists.hyperledger.org, in Hyperledger and W3C working groups, or at the semi-annual Internet Identity
            Workshop conferences.</p>
    </section>
</section>

</body>
</html>
