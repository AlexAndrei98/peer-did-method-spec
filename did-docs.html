<h2>DID Doc Structure</h2>
<section>
    <h3>CRDTs</h3>
    <p>Because peer DID Docs can be updated by multiple parties at the same time (as when two agents rotate their
        keys without coordinating), they have the potential for merge conflicts. Resolving these merge conflicts could
        introduce much complexity in this DID method, but peer DID Docs use a clever technique that avoids the issue
        entirely. The docs are carefully defined in such a way that they are <a target="wikipedia"
                href="https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type">conflict-free replicated data types</a>
        (<dfn>CRDTs</dfn>).</p>
    <p>CRDTs are a deep subject unto themselves, and additional study on the web is recommended. Here, we will
        simply note some key requirements that they impose on DID Doc structure.</p>
    <ol>
        <li>Core building blocks of DID Docs&mdash;keys, rules, and service endpoints&mdash; must be assigned
            <code>id</code> properties in a way that prevents collisions.</li>
        <li>Lists of these core building blocks must be paired with a corresponding <dfn>deletion list</dfn>. These
            are lists of strings that contain the <code>id</code>s of deleted items. Deletion is irreversible, in
            that items written to this list can never be removed. An <code>id</code> that appears in a deletion
            list SHOULD NOT also appear in <code>publicKey</code>, but even if it does, it is unusuable.</li>
        <li>All identified items must be considered immutable. Although we can casually speak of operations like
            key rotation or rule changes as if they were in-place edits, edits must actually be modeled by an
            implementation as the deletion of an old item and the insertion of a new one.</li>
        <li>When any party encounters two versions of a peer DID doc, one of which has an item in undeleted state and
            one of which has the item in a deleted state, the item's state should be considered deleted, regardless
            of relative timing of the two versions. This eliminates the possibility that a malicious party could
            attempt to take advantage of differences in system clocks or sequencing.</li>
    </ol>
    <p>Details about CRDT requirements are documented below, in the sections about individual parts of the DID Doc.
        These will make the CRDT semantics and the technique clearer.</p>
</section>
<section>
    <h3><code><dfn>publicKey</dfn></code></h3>
    <p>The <code>publicKey</code> section of a peer DID document is as you would expect from a reading of the
        <a target="didspec" href="https://w3c-ccg.github.io/did-spec/#authentication">DID spec</a>. Peer DID Docs
        MUST do all of their key definition in this section, even though the DID spec permits some DID methods to
        allow inline definitions in the <code>authentication</code> and <code>authorization</code> sections of a DID
        Doc.
    </p>
    <p>All <code>id</code> properties associated with a key defined internally in the DID Doc MUST be in
        relative, not absolute form (that is, "#xyz" instead of "did:peer:abc#xyz"). IDs for keys defined
        interally may be generated in either of these two ways:
    </p>
    <ul>
        <li>The first 8 characters of the key's unique representation may be used as the <code>id</code>, if this
            provides enough uniqueness within the document. (Global uniqueness is irrelevant.) For example, if the
            key is defined with a <code>publicKeyBase58</code> property value that begins with <code>H3C2AVvL</code>,
            then its <code>id</code> would be <code>H3C2AVvL</code>; a key with a <code>publicKeyHex</code> property
            that begins with <code>02b97c30</code> would have an <code>id</code>of <code>02b97c30</code>, and a key
            with a <code>publicKeyPem</code> property that begins, after its <code>-----BEGIN PUBLIC KEY</code>
            delimiter, with the value <code>izfrNTmQ</code>, would have an <code>id</code> of <code>izfrNTmQ</code>.
        </li>
        <li>A standard 128-bit UUID of type 1, 2, 3, 4, or 5 (see [[!RFC4122]]), rendered with hyphens and in lower
            case (as required by the UUID RFC), may be used as the<code>id</code> instead.</li>
    </ul>
    <p class="note">All IDs in DID Docs, including these, should be considered case-sensitive. Ignoring case will result
        in invalid comparisons for key <code>id</code>s based on encodings that are not hex.
    </p>
    <p>Because peer DIDs usually operate independent of global registries, external references (where <code>controller</code>
        is not <code>#id</code>) will probably be rare, with the possible exception of <a target="aries"
                href="https://github.com/hyperledger/aries-rfcs/blob/master/concepts/0046-mediators-and-relays/README.md">
            mediator</a> keys that have the <a>route</a> privilege.
    </p>
    <pre class="example" title="Sample publicKey section" data-include="sample-publicKey-section.json">
    </pre>
    <p>Elliptic curve keys (Ed25519, Secp256) are preferred because the keys are smaller, the number
        of bits of security are greater, and the computations more efficient, than RSA key types.</p>
    <section>
        <h4><code>publicKey~deleted</code></h4>
        <p>The <code>publicKey</code> section is paired with a <code>publicKey~deleted</code> list, which is a sibling
            to <code>publicKey</code> at the root of the document. This list of strings enumerates the <code>id</code>s
            of all keys that have been revoked, rotated, or otherwise removed from the document. Any time a key is
            added to <code>publicKey~deleted</code>, it should also be removed from <a href="#example-4-sample-authorization-section">
                <code>authorization.profiles</code></a>. An example of a <code>publicKey~deleted</code> list might be:
        </p>
        <pre class="example" title="Sample publicKey.deleted section">
{
    ...
    "publicKey~deleted": ["izfrNTmQ", "e3080168"]
    ...
}
            </pre>
    </section>
</section>
<section>
    <h3><code><dfn>authentication</dfn></code></h3>
    <p>The <code>authentication</code> section of a peer DID document conforms to <a target="didspec"
            href="https://w3c-ccg.github.io/did-spec/#authentication">standard practice described in the DID spec</a>,
        with the constraint that only references, not inline key definitions, are allowed. Any keys referenced
        here may be used to authenticate or login as the DID.
    </p>
    <p>However, the meaning of "authenticate" or "login" deserves comment, because there is a tendency in DID
        circles to reference too many keys in this section, and because heavy use of this section is discouraged
        with peer DIDs.
    </p>
    <p>A sovereign domain (the scope of things under the control of a single, sovereign identity owner) may include
        keys that represent the identity owner with greater or lesser degrees of trust. For example, the
        identity owner may hold one key on paper, locked in a safe; she may hold another key on a mobile device's
        secure enclave, protected by a biometric; she may hold a third on a server in a config file protected
        only by an ACL. These keys may all be legitimate evidence that the DID subject is interacting, but
        they are not equally strong evidence. Only the strongest forms of evidence should be accepted as a
        basis for authentication when stakes are high.</p>
    <p>This is not unlike what happens on the political landscape. A low-level diplomat and the president / premier
        / prime minister of a nation are both authentic representatives of their people&mdash;but the scope of their
        privileges, and the concomitant trust, are different. Only the highest-level officials should be signing
        binding international treaties.
    </p>
    <p>The <a href="#authorization"><code>authorization</code> section</a> of peer DID Docs, described next, is
        where fine-grained privileges are described. The <code>authentication</code> section is a blunt instrument,
        incapable of distinguishing between these levels of trust, and incapable of associating trust to anything
        more complex than a single key. It is supported for historical reasons, and because most so-called "DID
        Authentication" use cases assume it will be populated. With peer DIDs, the strong recommendation is that
        only keys held by the most trusted proxies should be referenced here. Only list the equivalent of your
        president / premier / prime minister keys in this section, not the equivalent of keys for your low-level
        diplomats. This will prevent impersonation by less trusted keys when stakes are high.
    </p>
    <section>
        <h4><code>authentication~deleted</code></h4>
        <p>The <code>authentication</code> section is paired with a <code>authentication~deleted</code> list, which
            is a sibling to <code>authentication</code> at the root of the document. This list of strings enumerates
            the <code>id</code>s of all keys that have been removed from the <code>authentication</code> section of the
            document. An example of a <code>authentication.deleted</code> list might be:
        </p>
        <pre class="example" title="Sample authentication.deleted section">
{
    ...
    "authentication.deleted": ["MNam3uVA", "32a769b4-081b-488b-8971-b4eee62f4c94"]
    ...
}
            </pre>
    </section>

</section>
<section>
    <h3><code><dfn>authorization</dfn></code></h3>
    <p>Peer DID docs organize their <code>authorization</code> section into two sequences. The first, <code>profiles
    </code>, gives a <dfn>trust profile</dfn> for each key, as expressed by named roles the key holds. These
        named roles are arbitrary strings chosen by the implementer; their meaning in normal language need not
        be understood by a party wishing to understand the semantics.
    </p>
    <p>The second sequence contains <a href="https://evernym.github.io/sgl" target="sgl">SGL</a> rules that grant
        privileges according to named roles. Here is an example that assumes keys with numeric IDs have been defined
        in a preceding <a href="#publickey"><code>publicKey</code></a> section:
    </p>

    <pre class="example" title="Sample authorization section">
“authorization”: {
    "profiles": [
        {"key": "#1", "roles", ["edge"]},              // key #1 is an "edge" key
        {"key": "#2", "roles", ["edge", "biometric"]}, // key #2 is an "edge" and a "biometric" key
        {"key": "#3", "roles", ["cloud"]},             // key #3 is a "cloud" key
        {"key": "#4", "roles", ["offline"]},           // key #4 is an "offline" key
    ],
    "rules": [
        { "grant": ["route", "authcrypt"], "when": {"roles": "cloud"}, "id": "98c2c9cc" },
        { "grant": ["authcrypt", "plaintext", "sign"], "when": {"roles": "edge"}, "id": "e1e7d7bc" },
        {
            "grant": ["key_admin", "se_admin", "rules_admin"],
            "when": {
                "any": [{"roles": "offline"}, {"roles": "biometric"}],
                "n": 2
            }
            "id": "8586d26c"
        }
    ]
}
        </pre>
    <p>In plain english, these rules say:</p>
    <ul>
        <li>Let a key have the "route" and "encrypt" privileges when its set of roles contains "cloud".</li>
        <li>Let a key have the "encrypt" and "decrypt" privileges when its set of roles contains "edge".</li>
        <li>Let any 2 keys, acting together, have the "kadmin" and "eadmin" privileges when their roles each contain
            either "offline" or "biometric".</li>
    </ul>
    <p>Far more elaborate rules could be constructed. See the <a target="sgl" href="https://evernym.github.io/sgl">
        SGL documentation</a> for details.</p>

    <section>
        <h4>Privilege Inventory</h4>
        <p>Unlike role names, the privileges named in these rules DO need to be understood by code that parses peer
            DID Docs; it is these privileges that others in a relationship should enforce. Possible values include:</p>
        <dl>
            <dt><dfn>route</dfn></dt>
            <dd>The holder of this privilege is allowed to receive and decrypt <a target="aries"
                    href="https://github.com/hyperledger/aries-rfcs/tree/master/concepts/0094-cross-domain-messaging#required-mediators-process-forward-messages">
                DIDComm <code>forward</code> messages</a> encrypted for itself, and to forward the contained
                <a href="https://github.com/hyperledger/aries-rfcs/blob/master/features/0019-encryption-envelope/README.md"
                        target="aries">DIDComm encryption envelope</a> to another key. Holders of these keys thus become aware
                of the timing and size of some incoming messages for the recipient (though not of the messages' senders
                or content). This privilege is required and appropriate for any cloud agent or <a target="aries"
                        href="https://github.com/hyperledger/aries-rfcs/blob/master/concepts/0046-mediators-and-relays/README.md">
                    mediator</a> that exposes a service endpoint on behalf of mobile devices or other agents behind a
                firewall.</dd>

            <dt><dfn>authcrypt</dfn></dt>
            <dd>The holder of this privilege is allowed to create messages and send them with <a target="wikipedia"
                    href="https://en.wikipedia.org/wiki/Authenticated_encryption">authenticated encryption</a>
                that reveals the identity of the sender to the reciever. Most agents are likely to have this privilege,
                but one designed for passive reception only (e.g., on an IoT sensor) might have it removed; doing so
                would prevent a hacker from co-opting such a key into sending in a trusted way. Messages that are
                authcrypted by a key that lacks this privilege should be rejected as illegal.</dd>

            <dt><dfn>plaintext</dfn></dt>
            <dd>The holder of this privilege can see <a target="aries"
                    href="https://github.com/hyperledger/aries-rfcs/tree/master/features/0044-didcomm-file-and-mime-types#didcomm-messages-dm">
                plaintext DIDComm messages</a> intended for an identity owner engaged in a <a target="aries"
                    href="https://github.com/hyperledger/aries-rfcs/blob/master/concepts/0003-protocols/README.md">protocol
            </a>. External parties sending to the owner of a given DIDDoc should multiplex encrypt for all keys that
                hold this privilege, except in special circumstances.</dd>

            <dt><dfn>sign</dfn></dt>
            <dd><p>The holder of this privilege can incur binding, contractual obligations on behalf of the DID subject.
                This may actually be a better test for login or authentication, in many cases, than whether a key appears
                in the <a href="#authentication"><code>authentication</code> section</a> of the DID Doc; it depends on
                what trust is imputed after login.</p>
                <p class="note">Any key holder can sign a DIDComm message; doing so gives non-repudiation to the
                    message. However, remember our <a href="#authentication">earlier discussion</a> about low-level
                    diplomats versus the president or prime minister of a country&mdash;both are authentic officials,
                    but only the president or prime minister's signature is binding on an international treaty. This
                    privilege makes explicit that sort of special binding-the-owner status; any other signatures
                    serve to prove origin with a specific agent but not the endorsement of the DID subject.
                </p></dd>

            <dt><dfn>key_admin</dfn></dt>
            <dd>The holder of this privilege can add or remove other keys from a peer DID Doc's <a href="#publickey">
                <code>publicKey</code> section</a>, <a href="#authentication"><code>authentication</code> section</a>,
                or <code>authorization.profiles</code> list. Typically this privilege is held only by very privileged
                keys, or by combinations of keys, to prevent hackers who co-opt one device from adding new, malicious
                keys to the inventory.
            </dd>

            <dt><dfn>se_admin</dfn></dt>
            <dd><p>The holder of this privilege can add or remove items from a peer DID Doc's <a href="#serviceendpoint">
                <code>serviceEndpoint</code> section</a>.</p>
            </dd>

            <dt><dfn>rules_admin</dfn></dt>
            <dd><p>The holder of this privilege can add or remove rules from a peer DID Doc's <code>authorization.rules
            </code> list. Typically this privilege is held only by very privileged keys, or by combinations of keys.</p>
            </dd>

            <dt><code>rotate</code></dt>
            <dd>The holder of this privilege can replace its associated key definition, and all references to that
                key throughout a DID Doc, with a new key definition and references, in a single delete-and-add
                operation. If key #2 has this privilege and exercises it, the result is that key #2 is revoked from
                the doc, but a new key (perhaps key #7) appears with exactly the same profile. This privilege is
                assumed to be held by all keys unless rules specify otherwise.
            </dd>
        </dl>
    </section>
    <section>
        <h4><code>rules~deleted</code></h4>
        <p>Notice that in the example above, each rule has an <code>id</code> property. This property can be
            assigned in any way that an implementation likes, as long as the values are unique within the document.
            This property is used to maintain a <a>deletion list</a> for the rules. The <code>authorization.rules
            </code> array is paired with a <code>rules~deleted</code> list, which is a sibling to <code>rules</code>
            below <code>authorization</code>. This list of strings enumerates the <code>id</code>s of all rules that
            have been removed from the <code>authorization.rules</code> list. An example of a <code>rules~deleted
            </code> list might be:
        </p>
        <pre class="example" title="Sample authorization.rules~deleted section">
{
    ...
    "authorization": {
        ...
        "rules": [ ... ]
        "rules~deleted": ["rule-1", "32a769b4"]
        ...
    }
    ...
}
            </pre>
        <p class="note">The <code>authorization.profiles</code> section does not have a <a>deletion list</a>.
            This is because the profile of a key is immutable&mdash;it cannot change for the lifetime of a key. Once
            a key is deleted, it is automatically removed from the profiles list (or treated as if it were removed).
        </p>
    </section>
</section>
<section>
    <h3><code><dfn>serviceEndpoint</dfn></code></h3>
    <p>This section matches the <a target="didspec" href="https://w3c-ccg.github.io/did-spec/#service-endpoints">
        general description in the DID Spec</a>.</p>
    <section>
        <h4><code>serviceEndpoint~deleted</code></h4>
        <p>Each service endpoint has a unique <code>id</code>. The <code>serviceEndpoint~deleted
        </code> list is thus a list of <code>id</code>s that have been deleted from the <code>serviceEndpoint</code>
            section of the doc, functioning in the same way as other <a>deletion lists</a>.</p>
    </section>
</section>
